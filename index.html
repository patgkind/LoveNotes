<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Love Notes</title>
  <style>
    html, body { height: 100%; }
    body {
      margin: 0;
      background: #f7f7f7;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    #board {
      position: relative;
      width: calc(100% - 20px);
      height: calc(100vh - 20px);
      margin: 10px;
      background: #fff;
      border: 2px solid #ccc;
      border-radius: 10px;
      overflow: hidden;
    }
    /* outlines in modes */
    #board.edit-outline { outline: 2px dashed #4caf50; outline-offset: -6px; }
    #board.delete-outline { outline: 2px dashed #e53935; outline-offset: -6px; }

    .note {
      position: absolute;
      min-width: 180px;
      min-height: 110px;
      padding: 10px 10px 12px 10px;
      border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
      cursor: grab;
      user-select: none;
    }
    .note.editing { cursor: default; }

    .note textarea {
      width: 100%;
      height: 100%;
      border: none;
      background: transparent;
      resize: none;
      outline: none;
      font-size: 14px;
      line-height: 1.35;
      pointer-events: none;
    }
    .note.editing textarea,
    .note.adding textarea { pointer-events: auto; }

    /* pin badge top left */
    .pin-badge {
      position: absolute;
      top: 6px;
      left: 8px;
      font-size: 18px;
      cursor: pointer;
      opacity: 0.9;
      user-select: none;
    }

    /* delete badge top right */
    .delete-badge {
      position: absolute;
      top: -6px;
      right: -6px;
      background: #e53935;
      color: #fff;
      width: 20px;
      height: 20px;
      border-radius: 10px;
      display: none;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      cursor: pointer;
      box-shadow: 0 2px 4px rgba(0,0,0,0.25);
      user-select: none;
    }
    .note.show-delete .delete-badge { display: flex; }

    /* color button top right, inside note */
    .color-btn {
      position: absolute;
      top: 6px;
      right: 6px;
      width: 22px;
      height: 22px;
      border: 1px solid rgba(0,0,0,0.25);
      border-radius: 4px;
      cursor: pointer;
      display: none;
      padding: 0;
    }
    .note.editing .color-btn,
    .note.adding .color-btn { display: block; }

    /* hidden color input placed near the note for OS picker */
    .color-input {
      position: absolute;
      top: 28px;
      right: 6px;
      width: 0;
      height: 0;
      border: none;
      padding: 0;
      opacity: 0;
      pointer-events: none;
    }

    /* FAB */
    #fab {
      position: fixed;
      bottom: 20px;
      right: 20px;
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 10px;
      z-index: 9999;
    }
    #fabMain {
      width: 56px;
      height: 56px;
      border-radius: 50%;
      border: none;
      background: #2196f3;
      color: #fff;
      font-size: 28px;
      cursor: pointer;
      box-shadow: 0 2px 8px rgba(0,0,0,0.35);
    }
    #fabOptions {
      display: none;
      flex-direction: column;
      gap: 8px;
    }
    #fabOptions button {
      border: none;
      border-radius: 8px;
      padding: 8px 12px;
      background: #4caf50;
      color: #fff;
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(0,0,0,0.25);
      font-size: 14px;
    }
    #fabOptions button:hover { filter: brightness(0.95); }
  </style>
</head>
<body>
  <div id="board"></div>

  <div id="fab">
    <div id="fabOptions">
      <button id="addNote">Add Note</button>
      <button id="addImage">Add Image</button>
      <button id="editMode">Edit Mode</button>
      <button id="deleteMode">Delete Mode</button>
    </div>
    <button id="fabMain">+</button>
  </div>

  <script>
    const API_URL = "https://script.google.com/macros/s/AKfycbyOgP36dXRLEoXmmg3KHUfPNuprLSVTo1k57aQYC8VkYfP4vdROq4X3lhFMvOHyQ1dgKw/exec";

    const board = document.getElementById("board");
    const fabMain = document.getElementById("fabMain");
    const fabOptions = document.getElementById("fabOptions");
    const addNoteBtn = document.getElementById("addNote");
    const addImageBtn = document.getElementById("addImage");
    const editModeBtn = document.getElementById("editMode");
    const deleteModeBtn = document.getElementById("deleteMode");

    let mode = "normal";         // normal, edit, delete
    let selectedNoteId = null;   // used in edit mode
    let noteMap = {};            // id -> DOM element
    let noteHash = {};           // id -> hash to avoid re-render
    let zCounter = 1;

    // contrast helper
    function textColorFor(bg) {
      const c = (bg || "#ffffff").replace("#", "");
      if (c.length !== 6) return "#000";
      const r = parseInt(c.slice(0,2), 16);
      const g = parseInt(c.slice(2,4), 16);
      const b = parseInt(c.slice(4,6), 16);
      const lum = 0.299*r + 0.587*g + 0.114*b;
      return lum > 140 ? "#000" : "#fff";
    }

    function hashOf(n) {
      return [n.text, n.color, n.x, n.y, n.pinned ? "1" : "0", n.image || ""].join("|");
    }

    // FAB
    fabMain.addEventListener("click", () => {
      fabOptions.style.display = fabOptions.style.display === "flex" ? "none" : "flex";
    });
    document.addEventListener("click", e => {
      if (!fabMain.contains(e.target) && !fabOptions.contains(e.target)) {
        fabOptions.style.display = "none";
      }
    });

    addNoteBtn.addEventListener("click", onAddNote);
    addImageBtn.addEventListener("click", onAddImage);
    editModeBtn.addEventListener("click", toggleEditMode);
    deleteModeBtn.addEventListener("click", toggleDeleteMode);

    function toggleEditMode() {
      if (mode === "edit") {
        mode = "normal";
        selectedNoteId = null;
        board.classList.remove("edit-outline");
        updateBadges();
        Object.values(noteMap).forEach(el => {
          el.classList.remove("editing");
          const ta = el.querySelector("textarea");
          if (ta) ta.disabled = true;
        });
      } else {
        mode = "edit";
        selectedNoteId = null;
        board.classList.add("edit-outline");
        board.classList.remove("delete-outline");
        updateBadges();
      }
    }

    function toggleDeleteMode() {
      if (mode === "delete") {
        mode = "normal";
        board.classList.remove("delete-outline");
        updateBadges();
      } else {
        mode = "delete";
        board.classList.add("delete-outline");
        board.classList.remove("edit-outline");
        selectedNoteId = null;
        Object.values(noteMap).forEach(el => el.classList.remove("editing"));
        updateBadges();
      }
    }

    function updateBadges() {
      Object.values(noteMap).forEach(el => {
        if (mode === "delete") el.classList.add("show-delete");
        else el.classList.remove("show-delete");
      });
    }

    // Add Note flow
    async function onAddNote() {
      const x = 60, y = 60, color = "#fffa91";
      const res = await fetch(`${API_URL}?action=addNote&text=&color=${encodeURIComponent(color)}&x=${x}&y=${y}&pinned=false`);
      const data = await res.json();
      if (data && data.id) {
        const n = { id: data.id, text: "", color, x, y, pinned: false, image: "" };
        createOrUpdate(n, true);
        // focus stays until click outside
      }
      // pull latest to sync across clients
      void loadNotes();
    }

    async function onAddImage() {
      const url = prompt("Enter image URL");
      if (!url) return;
      const x = 80, y = 80, color = "#ffffff";
      const res = await fetch(`${API_URL}?action=addNote&text=&color=${encodeURIComponent(color)}&x=${x}&y=${y}&pinned=false&image=${encodeURIComponent(url)}`);
      const data = await res.json();
      if (data && data.id) {
        const n = { id: data.id, text: "", color, x, y, pinned: false, image: url };
        createOrUpdate(n, true);
      }
      void loadNotes();
    }

    // Build or patch a note
    function createOrUpdate(n, forceEdit = false) {
      const h = hashOf(n);
      const existing = noteMap[n.id];
      if (existing && noteHash[n.id] === h && !forceEdit) return;

      let el = existing;
      if (!el) {
        el = document.createElement("div");
        el.className = "note";
        el.style.zIndex = zCounter++;
        noteMap[n.id] = el;
        board.appendChild(el);
        makeDraggable(el, n.id);
      }
      noteHash[n.id] = h;

      el.style.left = n.x + "px";
      el.style.top = n.y + "px";
      el.style.background = n.color;
      el.style.color = textColorFor(n.color);
      el.innerHTML = "";

      // pin
      const pin = document.createElement("div");
      pin.className = "pin-badge";
      pin.textContent = "ðŸ“Œ";
      pin.title = n.pinned ? "Unpin" : "Pin";
      pin.style.opacity = n.pinned ? "1" : "0.75";
      pin.addEventListener("click", async (e) => {
        e.stopPropagation();
        n.pinned = !n.pinned;
        pin.title = n.pinned ? "Unpin" : "Pin";
        pin.style.opacity = n.pinned ? "1" : "0.75";
        await fetch(`${API_URL}?action=editNote&id=${encodeURIComponent(n.id)}&pinned=${n.pinned ? "true" : "false"}`);
        void loadNotes();
      });
      el.appendChild(pin);

      // delete badge
      const del = document.createElement("div");
      del.className = "delete-badge";
      del.textContent = "x";
      del.title = "Delete";
      del.addEventListener("click", async (e) => {
        e.stopPropagation();
        if (mode !== "delete") return;
        await fetch(`${API_URL}?action=deleteNote&id=${encodeURIComponent(n.id)}`);
        if (noteMap[n.id]) {
          noteMap[n.id].remove();
          delete noteMap[n.id];
          delete noteHash[n.id];
        }
        void loadNotes();
      });
      el.appendChild(del);

      // textarea
      const ta = document.createElement("textarea");
      ta.value = n.text || "";
      ta.disabled = !(forceEdit || (mode === "edit" && selectedNoteId === n.id));
      ta.style.color = textColorFor(n.color);
      el.appendChild(ta);

      // color button + input
      const colorBtn = document.createElement("button");
      colorBtn.className = "color-btn";
      colorBtn.style.background = n.color;

      const colorInput = document.createElement("input");
      colorInput.type = "color";
      colorInput.className = "color-input";
      colorInput.value = n.color;

      colorBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        colorInput.click();
      });

      colorInput.addEventListener("input", async (e) => {
        const val = e.target.value;
        el.style.background = val;
        colorBtn.style.background = val;
        ta.style.color = textColorFor(val);
        n.color = val;
        await fetch(`${API_URL}?action=editNote&id=${encodeURIComponent(n.id)}&color=${encodeURIComponent(val)}`);
        noteHash[n.id] = hashOf(n);
        // no full reload here
      });

      el.appendChild(colorBtn);
      el.appendChild(colorInput);

      // selection and editing behavior
      el.addEventListener("mousedown", () => {
        el.style.zIndex = zCounter++;
      });

      el.addEventListener("click", (e) => {
        if (mode === "edit") {
          // select this note to edit
          Object.values(noteMap).forEach(x => {
            x.classList.remove("editing");
            const xta = x.querySelector("textarea");
            if (xta) xta.disabled = true;
          });
          selectedNoteId = n.id;
          el.classList.add("editing");
          ta.disabled = false;
          ta.focus();
        }
      });

      // when adding, keep focus until click outside
      if (forceEdit) {
        el.classList.add("adding");
        ta.disabled = false;
        ta.focus();
      } else {
        el.classList.remove("adding");
      }

      // textarea save on blur or Enter
      ta.addEventListener("keydown", async (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          ta.blur();
        }
      });

      ta.addEventListener("blur", async () => {
        if (ta.disabled) return;
        const newText = ta.value;
        if (newText !== n.text) {
          n.text = newText;
          await fetch(`${API_URL}?action=editNote&id=${encodeURIComponent(n.id)}&text=${encodeURIComponent(newText)}`);
          noteHash[n.id] = hashOf(n);
          void loadNotes();
        }
        // exit edit if we were in adding
        if (el.classList.contains("adding")) {
          el.classList.remove("adding");
          ta.disabled = true;
        }
        if (mode === "edit") {
          // keep selected until click outside board
        }
      });

      // show or hide delete badge by mode
      if (mode === "delete") el.classList.add("show-delete");
      else el.classList.remove("show-delete");
    }

    // drag support, always on except when user clicks UI elements
    function makeDraggable(el, id) {
      let dragging = false, offX = 0, offY = 0;

      el.addEventListener("mousedown", (e) => {
        const tag = e.target.tagName;
        if (["TEXTAREA", "INPUT", "BUTTON"].includes(tag)) return;
        if (e.target.classList.contains("pin-badge")) return;
        if (mode === "delete") return;
        dragging = true;
        const rect = el.getBoundingClientRect();
        offX = e.clientX - rect.left;
        offY = e.clientY - rect.top;
        el.style.cursor = "grabbing";
        e.preventDefault();
      });

      document.addEventListener("mousemove", (e) => {
        if (!dragging) return;
        const b = board.getBoundingClientRect();
        const nx = e.clientX - b.left - offX;
        const ny = e.clientY - b.top - offY;
        el.style.left = nx + "px";
        el.style.top = ny + "px";
      });

      document.addEventListener("mouseup", async () => {
        if (!dragging) return;
        dragging = false;
        el.style.cursor = "grab";
        const nx = parseInt(el.style.left, 10);
        const ny = parseInt(el.style.top, 10);
        await fetch(`${API_URL}?action=editNote&id=${encodeURIComponent(id)}&x=${nx}&y=${ny}`);
        // quick pull to sync across clients
        void loadNotes();
      });
    }

    // click outside ends adding or edit selection
    document.addEventListener("click", (e) => {
      if (!board.contains(e.target)) {
        // outside board ends edit or adding
        Object.values(noteMap).forEach(el => {
          if (el.classList.contains("adding") || el.classList.contains("editing")) {
            const ta = el.querySelector("textarea");
            if (ta) ta.blur();
            el.classList.remove("adding", "editing");
            if (ta) ta.disabled = true;
          }
        });
        selectedNoteId = null;
      }
    });

    // data loading with smart diff
    async function loadNotes() {
      try {
        const res = await fetch(`${API_URL}?action=getNotes`, { cache: "no-store" });
        const list = await res.json();
        const seen = new Set();
        list.forEach(n => {
          seen.add(n.id);
          createOrUpdate(n);
        });
        // remove stale
        Object.keys(noteMap).forEach(id => {
          if (!seen.has(id)) {
            noteMap[id].remove();
            delete noteMap[id];
            delete noteHash[id];
          }
        });
      } catch (err) {
        console.error("loadNotes error", err);
      }
    }

    // periodic poll as fallback
    loadNotes();
    let pollTimer = setInterval(loadNotes, 4000);
  </script>
</body>
</html>
